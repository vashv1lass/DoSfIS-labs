/**
 * @file set.hpp содержит объявления всех методов для класса set.
 * @author Вашкевич Максим Викторович, гр. 421702
 */

#ifndef SET_HPP
#define SET_HPP

#include <variant>
#include <cstdlib>
#include <string>
#include <iostream>

/**
 * @class set
 * @brief Класс для представления множества.
 * @details В объекте класса set могут храниться строковые элементы (строковые элементы могут содержать любые символы,
 * за исключением спец. символов и кавычек) и другие множества. Вложенность множеств не ограничена.
 */
class set {
private:
	/// @brief Внутренний массив для хранения элементов множества
	std::variant<char *, set> *m_data;
	/// @brief Текущая вместимость внутреннего массива
	size_t m_capacity;
	
	/// @brief Текущий размер множества (количество элементов)
	size_t m_size;
	
	/**
     * @brief Вспомогательный метод для расширения внутреннего массива при необходимости.
     * @details Увеличивает вместимость внутреннего массива в 2 раза при достижении текущего размера вместимости.
     */
	void m_expand_if_necessary();
	
	/**
     * @brief Вспомогательный метод для поиска позиции элемента в множестве.
     * @param elem Элемент для поиска
     * @return Позицию элемента в массиве или static_cast<size_t>(-1) если элемент не найден
     */
	[[nodiscard]] size_t m_find_pos(const std::variant<char *, set> &) const noexcept;
public:
	/**
	 * @brief Конструктор для set по умолчанию.
	 * @details Создаёт пустое множество.
	 */
	set();
	/**
	 * @brief Конструктор для set от std::string.
	 * @details Конвертирует строку std::string в множество.
	 * @param set_str должен являться валидным множеством, т. е. любое множество (внешнее, вложенное) должно быть
	 * заключено в фигурные скобки, элементы друг от друга должны отделяться запятыми. Атомарные строковые элементы
	 * могут содержать любые символы, кроме пробельных, фигурных скобок, спец. символов и др. Для поддержки фигурных
	 * скобок, пробелов, запятых в атомарном элементе, в записи множества этот элемент должен быть взят в кавычки.
	 * Лишние пробелы в записи множества не являются помехой для работы функции.
	 * @throws std::invalid_argument в случае, если переданная в функцию строка не является валидным множеством.
	 */
	explicit set(const std::string &);
	/**
	 * @brief Конструктор для set от C-style строки.
	 * @details Конструктор полностью аналогичен конструктору от std::string. @see документацию для
	 * set(const std::string).
	 */
	explicit set(const char *);
	
	/**
	 * @brief Конструктор копирования для set.
	 * @param other Копируемое множество.
	 */
	set(const set &);
	/**
	 * @brief Оператор присваивания для set.
	 * @param other присваиваемое множество.
	 * @return присвоенное множество.
	 */
	set &operator=(const set &);
	
	/**
	 * @brief Конструктор перемещения для set.
	 * @param other Адрес в памяти, откуда нужно переместить множество.
	 */
	set(set &&) noexcept;
	/**
	 * @brief Оператор перемещающего присваивания для set.
	 * @param other Адрес в памяти, откуда нужно переместить множество.
	 * @return Адрес в памяти, куда переместилось множество.
	 */
	set &operator=(set &&) noexcept;
	
	/**
	 * @brief Деструктор для set.
	 */
	~set();
	
	/**
	 * @brief Обмен значениями двух множеств.
	 * @param a Первое множество.
	 * @param b Второе множество.
	 */
	friend void swap(set &, set &) noexcept;
	
	/**
	 * @brief Оператор сравнения (равенство) двух множеств.
	 * @param other Правый операнд (левый – this).
	 * @return true Если множества равны.
	 * @return false Если множества не равны.
	 */
	bool operator==(const set &) const noexcept;
	/**
	 * @brief Оператор сравнения (неравенство) двух множеств.
	 * @details Противоположен оператору ==. @see документацию к bool operator==(const set &) const noexcept.
	 */
	bool operator!=(const set &) const noexcept;
	
	/**
	 * @brief Оператор ввода для множества.
	 * @details Получает из потока ввода строку множества и создаёт на её основании множество
	 * @param is Поток ввода
	 * @param s Вводимое множество
	 * @return Модифицированный поток ввода
	 */
	friend std::istream &operator>>(std::istream &, set &);
	/**
	 * @brief Оператор вывода для множества.
	 * @param os Поток вывода
	 * @param s Выводимое множество
	 * @return Модифицированный поток вывода
	 */
	friend std::ostream &operator<<(std::ostream &, const set &);
	
	/**
     * @brief Оператор проверки принадлежности элемента множеству.
     * @param elem Элемент для проверки (строка или множество)
     * @return true если элемент содержится в множестве, false в противном случае
     */
	bool operator[](const std::variant<char *, set> &) const noexcept;
	/**
     * @brief Оператор проверки принадлежности строки множеству.
     * @param atom Строка для проверки
     * @return true если строка содержится в множестве, false в противном случае
     */
	bool operator[](const char *) const noexcept;
	
	/**
     * @brief Получение мощности множества.
     * @return Количество элементов в множестве
     */
	[[nodiscard]] size_t cardinality() const noexcept;
	/**
     * @brief Проверка пустоты множества.
     * @return true если множество пустое, false в противном случае
     */
	[[nodiscard]] bool empty() const noexcept;
	
   /**
	* @brief Добавление элемента в множество.
	* @param elem Элемент для добавления (строка или множество)
	* @details Если элемент уже присутствует в множестве, операция не производится
	*/
	void insert(const std::variant<char *, set> &);
	/**
     * @brief Добавление строки в множество.
     * @param atom Строка для добавления
     * @details Если строка уже присутствует в множестве, операция не производится
     */
	void insert(const char *);
	
   /**
  	* @brief Удаление элемента из множества.
  	* @param elem Элемент для удаления (строка или множество)
  	* @details Если элемент отсутствует в множестве, операция не производится
  	*/
	void remove(const std::variant<char *, set> &);
	/**
     * @brief Удаление строки из множества.
     * @param atom Строка для удаления
     * @details Если строка отсутствует в множестве, операция не производится
     */
	void remove(const char *);
	
	/**
     * @brief Оператор объединения множеств с присваиванием.
     * @param other Множество для объединения
     * @return Ссылку на текущее множество после объединения
     */
	set &operator+=(const set &);
	/**
     * @brief Оператор объединения множеств.
     * @param other Множество для объединения
     * @return Новое множество - результат объединения
     */
	set operator+(const set &) const;
	
	/**
	 * @brief Оператор пересечения множеств с присваиванием.
  	 * @param other Множество для пересечения
     * @return Ссылку на текущее множество после пересечения
     */
	set &operator*=(const set &);
	/**
     * @brief Оператор пересечения множеств.
     * @param other Множество для пересечения
     * @return Новое множество - результат пересечения
     */
	set operator*(const set &) const;
	
	/**
     * @brief Оператор разности множеств с присваиванием.
     * @param other Множество для разности
     * @return Ссылку на текущее множество после разности
     */
	set &operator-=(const set &);
	/**
     * @brief Оператор разности множеств.
     * @param other Множество для вычитания
     * @return Новое множество - результат вычитания
     */
	set operator-(const set &) const;
	
	/**
     * @brief Построение булеана (множества всех подмножеств).
     * @return Новое множество, содержащее все подмножества текущего множества
     */
	[[nodiscard]] set powerset() const;
};

#endif // SET_HPP